<!doctype html>
<html>
<head>
	<title>CSS Basics and Style Guide</title>
</head>
<header>
	<div class="nav">
	<h2> Categories </h2>
	<ul>
		<li> Intro to CSS </li>
		<li> Links </li>
		<li> Adding Images </li>
		<li> Making Tables</li>
		<li> Creating Forms </li>
		<li> Embedding videos and audio </li>
	</ul>
</header>
<body>
	<H1>CSS Basics and Style Guide</H1>
	<section id=intro>
		<h2> Intro to CSS</h2>
		<p>After you've laid down the structure with html, it's time to decorate it with CSS. What is CSS? Every HTML element has a list of visual properties that can be changed or tweaked. CSS is basically a list of rules that set the values of those properties to what we want. There are two main ways to add a style sheet to our HTML. <dfn>Embedded style sheets</dfn> and <dfn>external style sheets</dfn>. 
		<br>Embedded style sheets are written right in the HTML. We just put a pair of <code>&lt;style&gt;...&lt;/style</code> tags in the <code>head</code> section of HTML and the CSS rules go right in between. </p>
		<figure><code><pre>
			&lt;head&gt;
				&lt;style&gt;
				<i>Style rules go here</i>
				.
				.
				&lt;/style&gt;
			.
			.
			.
		</pre></code></figure>
		<p> External style sheets are written as separate documents (.css) and linked to the HTML later. You can have multiple style sheets for the same HTML document. They'll all apply with some override if conflicts occur. There's no real formal structuring like &lt;head&gt; or &lt;body&gt; in a CSS document. Just list your rules and you're good. There are two ways to link an external style sheet.</p>
		<ol>
			<li><h3>Using the <code>&lt;link&gt;</code> Element</h3>
				<p>In the <code>head</code> of the document, place the following line:</p>
				<figure><code>&lt;link rel="stylesheet" href="<i>url to stylesheet</i>"&gt;</code></figure>
			</li>
			<li><h3>Using <code>@import</code></h3>
				<p>Right at the beginning of the <code>style</code> section of the document, place the following line:</p>
				<figure><code>@import url("<i>url to stylesheet</i>");</code></figure>
				<p> You can add <dfn>media queries</dfn> so that different style sheets are imported depending on the device. For example the following stylesheet is used when the webpage is printed.</p>
				<figure><code>@import url("<i>url to stylesheet</i>") print;</code></figure>
				<p>See the media queries section for more options</p>
			</li>
		</ol>
	





		<h3>CSS Syntax</h3>
		<p>The syntax of a CSS rule is as follows:</p>
		<figure><code><pre>
			selector{
				property: value;
				.
				.
				.
			}
		</pre></code></figure>
		<p>The <dfn>selector</dfn> is basically the name of the element we want to change (so whatever word is between the &lt; and &bgt;). Applying style rules to an element will apply them to every single instance of that element in the document. If we want to be more specific, we can use the selector to target classes or IDs; just use . or # respectively. We can even add multiple selectors - just separate them with a comma.
		We can use descendent selectors to target specific descendents of specific elements, just separate parent and child with a space. In the below example, only elementB elements that are children of elementA elements will be targetted by the enclosed rules. There's also the child selector which targets specific children of elements and sibling selector that targets specific elements that appear right after another element. If we want to target <em>every</em> child, descendent, or sibling or a specific element just use the wildcard selector (*).</p>
		<div class=threefigures>
			<figure><code><pre>
			element{
				property: value;
				.
				.
				.
			}
		</pre></code></figure>
		<figure><code><pre>
			element.class{
				property: value;
				.
				.
				.
			}
		</pre></code></figure>
		<figure><code><pre>
			#id{
				property: value;
				.
				.
				.
			}
		</pre></code></figure>
		<figure><code><pre>
			elementA elementB{
				property: value;
				.
				.
				.
			}
		</pre></code></figure>
		<figure><code><pre>
			elementA &gt; elementB{
				property: value;
				.
				.
				.
			}
		</pre></code></figure>
		</div>
		<p> The <code class=attribute>properties</code> are whatever properties are available in the element(s) you're targeting. The values are whatever we want to change it to. Formally, each property value pair is called a <dfn>declaration</dfn>. Each selector can have multiple declarations to change its appearance, collectively known as a <dfn>delcaration block</dfn>. 
		What if you have multiple declarations that target the same property on the same element, i.e. style conflicts? The general rule is the closer the rule is to the actual markup, the higher its priority. So an external style sheet would be overridden by an embedded style sheet which would be overridden by the element's HTML style values. Also the more specific a style rule is, the higher the priority. So an element selector would be overridden by a class selector which would be overridden by an id selector which would be overridden by the elements HTML style value.
		<br> Style inheritance is another feature of CSS. There are certain style properties that can be passed down by container elements to their child elements. For example: </p>
		<figure>
			<p>This is an unstyled <i>paragraph</i>.</p>
			<p style="font-family: cursive"> This is a styled <i>paragraph</i>. </p>
			
		</figure>
		<p> Both paragraphs elements above have the word 'paragraph' within &lt;i&gt; elements. The first paragraph has no styles. The second paragraph element is styled with a cursive font. Noticed how the cursive style is applied to 'paragraph' even though no style was applied specifically to that element. Thats the power of inheritance! In general, styles affecting text get passed down while styles affecting borders and backgrounds don't</p>
	</section>

	<section id="units">
		<h2>Units of Measurement</h2>
		<p>When designing web pages, its important to enforce how big things should be so that your users see your website as it should be, regardless of what device they use. There are two types of units: <dfn>Absolute</dfn> and <dfn>Relative</dfn>. Absolute units can be measured in real life because they always stay that size, regardless of the size of the screen. Relative units are based on the size of something else, whether its screen size or font size. The size can change depending on the state of the reference. In general we will want to use relative units of measurement to ensure our web content adapts with the user's device. Note: when inputtings units, make sure there's NO space between the unit and its value. Example. </p> 
		<dl>
			<h3>Absolute Units</h3>
			<dt><code>px</code></dt>
			<dd> Pixels, defined as 1/96 of an inch. This is pretty much the only absolute unit used in web design. Others exist like in for inches and cm for centimeters but they're not as appropriate for screens</dd>
			<h3>Relative Units</h3>
			<dt><code>em</code></dt>
			<dd> A unit based on the element's inherited font size, specifically the size of a capital 'M'. If the inherited font size is 12, then 1 em is equivalent to an 'M' in 12 size font.</dd>
			<dt><code>rem</code></dt>
			<dd> A unit based on the root font size (font size of the <code>HTML</code> element). By default, this is 16 pixels so 1 rem is equal to 16 pixels.</dd>
			<dt><code>vw|vh</code></dt>
			<dd> These stand for 'viewport width' and 'viewport height', respectively. They serve as percentage sizes based on the size of the viewport (browser window). For example a 100vw element would take up 100% of the viewports width.</dd>
		</dl>
	</section>
	<section id="Pseudo">
		<h2>Pseudo-Classes and Pseudo-Elements</h2>
		<p>CSS provides an additional way to select and group elements by their current <em>state</em>, instead of by user-defined classes, or relationships. These selectors are called <dfn>pseudo-class</dfn> selectors. They allow us to add additional styles based on the current state of an element; ex. whether it's been hovered over, clicked, etc. As stated earlier, the syntax for classes used '.' before the class name. For pseudo-classes, we use ':' before the pseudo-class name.</p>
		<dl>
			<h3>Pseudo-classes for Links</h3>
			<dt><code>a:link</code></dt>
			<dd>Applies a style for unclicked links</dd>
			<dt><code>a:visited</code></dt>
			<dd>Applies a style for clicked links</dd>
			<h3>Pseudo-classes for User Actions</h3>
			<dt><code><i>element</i>:focus</code></dt>
			<dd>Applies a style when the element is selected and is waiting for input, like a form element</dd>
			<dt><code><i>element</i>:hover</code></dt>
			<dd>Applies a style when the element is hovered over with a mouse pointer. No effect for mobile users</dd>
			<dt><code><i>element</i>:active</code></dt>
			<dd>Applies a style for that brief moment when an element is clicked and the mouse hasn't been released yet. Good for buttons and links. </dd>
		</dl>
		<p>Keep in mind the order you chain your pseudo-class styles when applying multiple for the same element. The styles applied last will override the others so if :link or :visted are applied last, then none of the others will appear. The order should be :link, :visited, :focus, :hover, then :active.<br>There are many other pseudoselectors, many of which target specific element relationships like <code>:first-child</code> and <code>only-child</code>. You can read more about them <a href="https://css4-selectors.com/selectors/">here</a></p>
		<h3> Pseudo-elements</h3>
		<p>Unlike pseudo-classes which offer group selection based on state or relationship, pseudo-elements allow you to target specific areas within the content of elements. The syntax for pseudo-elements is '<i>element</i>::<i><code>pseudo-element</code></i>'.</p>
		<dl>
			<dt><code><i>element</i>::first-line</code></dt>
			<dd>Use to apply a style rule to the first-line of the element</dd>
			<dt><code><i>element</i>::first-letter</code></dt>
			<dd>Use to apply a style rule to the last-line of the element</dd>
			<dt><code><i>element</i>::before</code></dt>
			<dd>Use to add additional content before the original content of the element. Use the <code>content</code> property to add more text (enclosed by quotation marks) or add an image using the url(...) syntax. Add any styles you want applied to the extra content in the same declaration block.
			</dd>
		</dl>
	</section>
	<section id="AttributeSelectors">
		<h2>More Attribute Selectors</h2>
		<p>We've seen the class and id selectors earlier. In reality, these were just special types of <dfn>attribute selectors</dfn>, selectors that target based on attribute names or values. Normal attribute selectors follow the syntax <i>element</i>[<code>attribute</code>].</p>
		<dl>
			<dt><code><i>element</i>[attribute]</code></dt>
			<dd>Apply a style to elements with the specified attribute.</dd>
			<dt><code><i>element</i>[attribute="value"]</code></dt>
			<dd>Apply a style to elements who have the specified attribute <strong>with</strong> the exact specified value</dd>
			<dt><code><i>element</i>[attribute~="value"]</code></dt>
			<dd>Apply a style to elements who have the specified attribute that <em>contains</em> the specified value as a word, separated by spaces.</dd>
			<dt><code><i>element</i>[attribute|="value"]</code></dt>
			<dd>Apply a style to elements that have the specified attribute that has hyphen-separated values that has the specified value contained within</dd>
			<dt><code><i>element</i>[attribute^="first part of value"]</code></dt>
			<dd>Apply a style to elements that have the specified attritube that has a value that <em>starts with</em> the specified value</dd>
			<dt><code><i>element</i>[attribute$="last part of value"]</code></dt>
			<dd>Apply a style to elements that have the specified attribute that has a value that <em>ends with</em> the specified value</dd>
			<dt><code><i>element</i>[attribute*="any part of value"]</code></dt>
			<dd>Apply a style to elements that have the specified attribute that has the specified value as a substring in its value</dd>
		</dl>
	</section>
	<section id="boxes">
		<h2>Element Boxes</h2>
		<p> When elements are placed on a page, they take up space. This is obvious with block elements but even in-line elements have their contents enclosed by boxes. Each of these element boxes is made up of the area taken up by the content, followed by any padding, the border, and then any margins. The padding is the space between the content box and the border. The margins are any space maintained between other elements as well as between the viewport edges. Margins have an interesting property called <dfn>collapsing margins</dfn>; when two vertically adjacent elements with margins meet, the space between them is <em>not</em>the combined total of their margins; it is the largest margin between the two elements. Horizontal margins never collapse.  In this section we'll look at ways to play around with element boxes.</p>
		<h3>Changing The Size of the Element Box</h3>
		<dl>
			<dt><code>width</code><br>Values:rem,em,%,auto</dt>
			<dd>Used to change the width of the content box of the element, unless chnaged by the <code>box-sizing</code> property. By default, this is set to auto which means elements are as wide as the block element that contains it.</dd>
			<dt><code>height</code><br>Values:rem,em,%,auto</dt>
			<dd>Used to change the height of the content box of the element, unless changed by the <code>box-sizing</code> property. By default this is set to auto which means the box is just tall enough to fit the content.</dd>
			<dt><code>box-sizing</code><br>Values:content-box,border-box</dt>
			<dd>Changes whether <code>width</code> and <code>height</code> properties are applied to the content-box (default) or the border-box. "Content-box" means that any sizes you set for the <code>width</code> and <code>height</code> are only applied to the content-box. Any padding and margin sizes get slapped on top of that, so you might end up with something larger than expected. Changing it to "border-box" means the entire element (including margins and padding) will be the size you specify. </dd>
			<dt><code>overflow</code><br>Values:visible,hidden,scroll,auto</dt>
			<dd>Used to change how elements are displayed when the content is much larger than its box. By default, this is set to "visible", which means the extra content protrudes out of the box. "Hidden" clips off any extra content. "Scroll" adds a scroll bar to the box to view the extra content. "Auto" leaves the choice up to the browser.</dd>
			<dt><code>padding</code><br>Values:rem,em,%</dt>
			<dd>Adds padding to the element box. Takes up to 4 values (not comma separated), one for each of the sides. Order of the values changes top right bottom left padding in that order. <strong>Percentage units are relative to the width of the parent element, even for top and bottom paddding. Default value is 0 padding.</strong></dd>
			<dt><code>border-style</code><br>Values:none,solid,dotted,dashed,double,groove,ridge,inset,outset</dt>
			<dd>Changes the border style of the element. Takes up to 4 values (not comma separated), one for each side. Order fo the values is top right bottom left border, in that order. Default value is none.</dd>
			<dt><code>border-width</code><br>Values:px,rem,em,thin,medium,thick</dt>
			<dd>Changes the thickness of the border. Takes up to 4 values (not comma separated), one for each side. Order of the values is top right bottom left border, in that order. Default value is medium thickness.</dd>
			<<dt><code>border-color</code><br>Values:colorname,RGB,HSL,transparent</dt>
			<dd>Changes the color of the border. Takes up to 4 values (not comma separated), one for each side. Order of the values is top right bottom left border, in that order. Default value is whatever the <code>color</code> property is set to.</dd>
			<dt><code>border-radius</code><br>Values:px,rem,em,%</dt>
			<dd>Used to create rounded border corners. Values can be specified for each corner (not comma separated), starting with the top-left corner and moving clockwise. Each corner can have one value for smooth, even, circular corners or they can have two values (horizontal and vertical radii, separated with a /) for interesting uneven elliptical corners. </dd>
			<dt><code>margin</code><br>Values:px,rem,em,%,auto</dt>
			<dd>Used to change the margins of the element box. Takes up to 4 values (not comma separated), one for each side. Order of the values is top right bottom left margin. <strong>Percentage units are relative to the width of the parent element, even for top and bottom paddding.</strong> Negative units cause neighbouring elements to overlap with the current one. Default value is "auto" which means the browser uses enough margin to fill any available space.  Non-replaced inline elements like <code>a</code> only have left and right margins. </dd>
			<dt><code>display</code><br>Values:inline,block,run-in,flex,flow,list-item,table,ruby,inline-block,inline-grid,contents,none</dt>
			<dd>Used to specify how elements behave in layouts. Default is "inline" but you can make items behave as though they're table items or list items. This is useful for changing the look of things without messing with the markup. The "none" value not only turns the element invisible, it removes it entirely and the space it filled is taken up by the other elements. This is useful for hiding elements from certain display types like the print view. Note that elements hidden in this way are still downloaded so this does nothing to save data.</dd>
			<dt><code>box-shadow</code><br>Values:inset,px,rem,em,colour</dt>
			<dd>Adds a shadow around the element box (excluding margin). The "inset" value is a toggle that enables shadows inside the box area and makes the box look like its sunken in rather than popping out; normally it is outside. There are four possible measurement values. The first two are mandatory: horizontal offset and vertical offset. The horizontal offset dictates how far to the right the shadow should be, relative to the box. The vertical offset dictates how far down the shadow should move, relative to the box. The third optional measurement is for the blur radius; the larger the blur radius, the softer the shadow becomes. The fourth optional measurement is for spread; the larger the spread, the bigger the shadow.The last value of this property is the colour of the shadow. If no colour is specified, it is the same as the element foreground (text and border). You can have multiple box shadows on the same element; just separate the sets with commas. They all get drawn on top of one another.</dd>
		</dl>
	</section>
	<section id="fontstyles">
		<h2>Font Properties</h2>
		<dl>
			<dt><code>font-family</code></dt>
			<dd> Use the <code>font-family</code> to specify a comma-separated list of fonts for that element. The browser will go in order from left-to-right until it finds a font it can render on the screen. For the most part, all font names must capitalized with the exception of generic ones (monospace, serif, sans-serif, cursive, fantasy). Fonts that have names that are more than one word require quotation marks. In general, your font stack should start with your first choice, followed by similar looking alternatives, and then end off with the closest generic font. <br>Click <a href="https://www.tutorialbrain.com/css_tutorial/css_font_family_list/" target="_blank">here</a> for a list of font-families to choose from.</dd>
			<dt><code>font-size</code><br>Values:rem,em,%</dt>
			<dd> Sets the size of the element's font. You can use the units mentioned earlier or percentage units. If you put a percentage, it scales the font up or down based on it's inherited font value. Its common practice to set the font-size of the <code>html</code> element to 100% (equal to 16px for all modern browsers) so we have a clear base going forward with the font-sizes of other elements.</dd>
			<dt><code>font-weight</code><br>Values:normal,bold,bolder,lighter,100,200,300,...,900</dt>
			<dd> Used to set how bold the font is. There are a lot of values but for the most part just stick with bold. You can also use normal to 'un-bold' things that normally appear bold like headlines.</dd>
			<dt><code>font-style</code><br>Values:normal,italic,oblique</dt>
			<dd> Used to set the font italic. Use normal to make un-slant things that are normally in italics like <code>em</code>.</dd>
			<dt><code>font-variant</code><br>Values:normal,small-caps</dt>
			<dd> Changes the font to use capital letters in place of lowercase letters. Good for times and units and maybe acronyms and abbreviations.</dd>
			<dt><code>font-stretch</code><br>Values:normal,ultra-condensed,condensed,semi-condensed,semi-expanded,expanded,extra-expanded,ultra-expanded,</dt>
			<dd>Changes the font-family to its normal|<span style="font-stretch: condensed;">condensed</span>|<span style="font-stretch:expanded">expanded</span> version. If the browser can't find one, it'll switch out the font-family with a different one.</dd>
			<dt><code>color</code><br>Values: black,white,purple,lime,navy,aqua,silver,maroon,fuchsia,olive,blue,orange,gray,red,green,yellow,teal,#RGB</dt>
			<dd> Changes the color of foreground elements: font and border. You can use predefined color names like black, red, or purple or RGB numbers.
			<dt><code>font</code><br>Values: style weight stretch variant size/line-height font-family</dt>
			<dd> Shorthand property that merges all the above properties into one. Property values must be typed in the order as seen in the values. Omitting any value means its default value is used instead. Saves space but easier to keep track if you specify all the properties individually.</dd>
		</dl>
		<h2> Line Styles</h2>
		<dl>
			<dt><code>line-height</code><br>Values: rem,em,%,#,normal</dt>
			<dd>Used to set the line height which is the space between baselines (the imaginary line where the letters sit). The line height is based on the current font size of the element. Units include your basic rem, em and % but also numerical values. When you use just a number, it acts a multipler (so '2' would mean a line-height that is 2x the current font size). It is important to note the difference in terms of inheritance. When you use a number multiplier, its descendents also inherit the multiplier. This means a descendent paragraph with a font size of 8px would have a line-height of 16px. However, when you use em, the descendents inherit the ancestor's calculated size. For example, lets say we have a <code>body</code> element with a line-height of 1em. Assuming default font size, this means the <code>body</code> element and <strong>all its descendents</strong> will have a line-height of 16px. This could be bad if we have elements like a 24px headline.</dd>
			<dt><code>text-indent</code><br>values:rem,em,%</dt>
			<dd>Used to set indent length. Percentage values are based on the length of the whole line. All relative units are passed down to descendents as relative not calculated so you won't see the same problem as <code>line-heights</code> You can use negative values to generate an overhang as opposed to an indent.</dd>
			<dt><code>text-align</code><br>Values:left,right,center,justify,start,end</dt>
			<dd>Adjust the position of the text within its block. Pretty straightforward. </dd>
			<dt><code>text-decoration</code><br>Values:none,underline,overline,line-through</dt>
			<dd>Adds special decoration to the element text.</dd>
			<dt><code>text-transform</code><br>Values:none,capitalize,lowercase,uppercase</dt>
			<dd>Transforms the element's text. Capitalize changes the first letter of every word in the element to a capital, whereas uppercase changes every letter to a capital</dd>
			<dt><code>letter-spacing</code><br>Values:rem,em,%,normal</dt>
			<dd>Adds space between letters. If you use em, descendents will inherit the calculated value, not the relative value so be careful.</dd>
			<dt><code>word-spacing</code><br>Values:rem,em,%,normal</dt>
			<dd>Adds space between words. Like <code>letter-spacing</code> if you use em, descendents will inherit the calculated value, not the relative value.</dd>
			<dt><code>text-shadow</code><br>Values:rem,em,none</dt>
			<dd> Creates a shadow behind the letters. There are three measurement values. The first two are mandatory: horizontal offset and vertical offset. The horizontal offset dictates how far to the right the shadow should be, relative to the actual letters. The vertical offset dictates how far down the shadow should move, relative to the letters. The third optional measurement is for the blur radius; the larger the blur radius, the softer the shadow becomes. The fourth and last value of this property is the colour of the shadow.</dd>
			<dt><code>list-style-type</code><br>Values:none,disk,circle,square,decimal,decimal-leading-zero,lower-alpha,upper-alpha,lower-latin,upper-latin,lower-roman,upper,roman,lower-greek</dt>
			<dd> Applies only to list elements. Changes the marker used to mark each item in the list. Use 'none' to remove the markers entirely.</dd>
			<dt><code>list-style-position</code><br>Values:inside,outside,hanging</dt>
			<dd>Applies only to list elements. Changes the position of the bullet, relative to the list item's box. Inside means inside the box. Outside means outside the box without touching it. Hanging is like inside with the markers just hanging on the outside edge of  the box.</dd>
			<dt><code>list-style-image</code><br>Values:url(),none</dt>
			<dd> Applies only to list elements. Use a specified image instead of conventional markers to separate list items. Use this property in conjunction with <code>list-style-type</code> in-case the image doesn't load.</dd>
		</dl>	
	</section>

	<section id="colour">
		<h2>Colour</h2>
		<p>There are a set 140 colours that all browsers can recognize the name of and render onto the screen (You can see the full list <a href="https://www.learningwebdesign.com/colornames.html">here</a>). However, there are alot more colour options to pick from if we use RGB values (255 values in each channel = 16.7 million colours!). You can use <a href="https://www.google.com/search?q=colour+picker&rlz=1C1CHBF_enCA805CA805&oq=colour+picker&aqs=chrome.0.0i433i457j0l7.1471j0j7&sourceid=chrome&ie=UTF-8">Google's colorpicker</a> to find the RGB values of your desired colour. To use RGB, we can just type in the values for each channel as shown below:</p>
			<figure><code>color: rgb(97,201,201);</code></figure>
		<p>We can also use hexadecimal values. The hex value below produces the same colour as the decimal value above.</p>
			<figure><code>color: #61c9c9;</code></figure>
		<h3>RGBa</h3>
		<p>The 'a' in RGBa stands for <dfn>alpha</dfn>. Essentially, it adds a fourth channel to RGB but this channel affects the colour's transparency rather than its hue.</p>
			<figure><code>color: rgba(97,201,201,.1);</code></figure>
		<p> The alpha value ranges from 0 to 1, with 0 being completely transparent and 1 being completely visible.</p>
		<h3>HSL and HSLa</h3>
		<p> Besides colour names and RGB values, there is a third way to define colours: <dfn>HSL</dfn>. HSL stands for Hue Saturation Luminosity. Imagine a circle with all the colours of the rainbow spread out as a gradient with red at the very top. The angles of each colour, with red being at the 0/360<sup>o</sup> position, correspond to the hue value. Saturation and luminosity are both percentage values. Saturation affects how much of that hue is rendered (0% means gray). Luminosity affects how light or dark you want to make that hue (100% gives you white, 0% gives you black). The following CSS shows the HSL equivalent of the examples above.</p> 
		<figure><code>color: hsl(180,49%,58%);</code></figure>
		<p> Like with RGBa, HSLa adds a fourth channel for transparency, with 0 being completely transparent and 1 being completely visible.</p>
		<h3>Background Colour</h3>
		<p>When applying colour to elements, it gets applied to the <dfn>foreground</dfn> elements: the text as well as any defined border. If we want to change the colour of the background, we need to use another property: <code>background-color</code>.</p>
		<dl>
			<dt><code>background-color</code><br>Values:colour name,RGB,HSL</dt>
			<dd>Applies a colour to the background of the element, which by default extends right to the outer edge of the border.</dd>
			<dt><code>background-clip</code><br>Values:border-box,padding-box,content-box</dt>
			<dd>Changes the area that the background covers. Default is border-box which extends the background to the outer edge of the border. Padding-box stops the background right before the border. Content-box limits the background to just around the content.</dd>
		</dl>
		<h3>Opacity</h3>
		<dl>
			<dt><code>opacity</code><br>Values:number between 0 and 1</dt>
			<dd>Changes the transparency of the entire element, foreground and background.</dd>
		</dl>
		<h3>Background Images</h3>
		<dl>
			<dt><code>background-image</code><br>Values:url(...)</dt>
			<dd> Uses an image source as the background for the element. Note: the URL is relative to the location of the CSS rule (so its external sheet location or the HTML file location). The behaviour is that the image starts in the top-left corner (right before the border) and repeats itself horizontally, then vertically, until the whole element box is filled. If you combine this with back-ground colour, the image goes on top of the colour. It's recommended you do so that if the image doesn't work, there's still a background colour to cover for it.</dd>
			<dt><code>background-repeat</code><br>Values:repeat,no-repeat,repeat-x,repeat-y,space,round</dt>
			<dd>Specifies how the background image repeats itself. Repeat is the default. No-repeat means the image shows only once. Repeat-x or Repeat-y means the image only repeats itself in the x or y direction. The space value is used to ensure that no clipping occurs when repeating; the browser calculates how many whole images can fit in the element, then adds space between them to fill out any gaps. The round value also prevents clipping but by changing the dimensions so that the image fits an even amount of times in the background.</dd>
			<dt><code>background-position</code><br>Values:rem,em,%,left,center,right,top,bottom</dt>
			<dd>Changes the position of where the image is first placed. Use rem or em to indicate offsets from the top-left corner. Or percentages are used in pairs to indicate horizontal and vertical offset (in that order) from the top left corner: 0% 0% for the top-left corner, 100% 100% for the bottom-right corner. As a final alternative, you can use the directional keywords to move your origin image around: 'left top' is the default but you could move it 'right bottom'. If you only specify one 'direction' like just 'right'. then the browser automatically assumes that the image should also be 'center'.</dd>
			<dt><code>background-origin</code><br>Values:border-box,padding-box,content-box</dt>
			<dd>As stated earlier, background images by default do not intersect the border area; this is the default value of padding-box. We can use <code>background-origin</code> to change this behaviour. If we change it to border-box, the origin image will go right to the outer edge of the border. If we change it to content-box, then the origin image will start within the content area (where the text is).</dd>
			<dt><code>background-attachment</code><br>Values:scroll,fixed,local</dt>
			<dd>Changes how the background image scrolls. The default value is scroll; the background image scrolls with the content. If we specify it to be fixed, then the background image stays put while the content scrolls over it. The local value is used when the element the background image is attached to has its own scroller; it ties the scrolling to the element's scroller and not the browsers'.</dd>
			<dt><code>background-size</code><br>Values:px,rem,em,%,auto,cover,contain</dt>
			<dd> Changes the size of the image used for the background. Two values are needed, one for each dimension. If only one is specified, it is assumed to be horizontal dimension and the vertical dimension is set to 'auto'. What auto does is it resizes in whatever direction is necessary to maintain the proportion of the image. Percentage values are based on the size of background positioning area, which itself is based on the value set in the <code>background-origin</code> property. The cover keyword resizes the image so that one copy covers the entire background positioning area. The contain keyword resizes the image either horizontally or vertically until it fits the background positioning area completely in that one dimension. If there is any leftover space, then the image repeats itself.</dd>
			<h4>Multiple background Images</h4>
			<p>You can add multiple background images by simply separating each image url with commas in the <code>background-image</code> property. Images "stack" on top of one another, with the first url's image on top, the next image under that, and so on. To use the other properties with each image separately, just separate the values with commas, in the same order as the images are stacked from top to bottom.</p>
			<h4>Gradients</h4>
			<p> You can add color gradients to your backgrounds as well. Even though no image is provided they still get treated as background-images and can be used anywhere a <code>background-image</code> property can be used.</p>
			<dt><code>background-image:linear-gradient(...)</code><br>Values:angle,startcolour,....,endcolour</dt>
			<dd> Generates a linear gradient with the <code>background-image</code> property. At least three values are needed in the brackets as shown below.
				<figure><code>background-image:linear-gradient(180deg, green, blue 40%, red)</code></figure> 
				The first is the angle, specified by #deg. A value of 0deg means the gradient goes from bottom to top. Positive angles turn gradient clockwise so at 90deg, the gradient goes from left to right. There are also keywords you can use although these restrict the angle to 45 degree increments (to top, to right, to left, to bottom, to top right, to top left, to bottom right, to bottom left). <br>The next values must be at least two colours, the start and end colours respectively, with as many of the colours you want in between. You can set colour stops by adding percentages after the colours; these tell the browser where along the gradient these colours should appear. In the example above, the colour blue is set to appear at 40% of the gradient. By default the start and end colours appear at 0% and 100% respecitvely. If a colour stop is specified for the start colour, then the gradient will be filled with just the start colour up until that stop point. If a colour stop is used for the end colour, then the gradient will be filled with that last colour from the stop point all the way to the end.</dd>
			<dt><code>background-image:radial-gradient(...)</code><br></dt>
			<dd> Creates a gradient that by default, radiates from the center of the element. This generates a circle if the element is square or an ellipse of the element is rectangular. Two colours at least are required for the start and end colours. You can change the shape by specifying either 'circle' or 'ellipse' or by supplying horizontal and vertical dimensions. You can change where teh gradiant begins by using the same keywords for the <code>background-position</code> property.</dd>
		</dl>
	</section>
	<section id="floats">
		<h2>Floating Elements</h2>
		<p>Floating an element means pushing it off to the side and allowing other elements to flow or wrap around it. This can be useful for saving space and can also make your overall layout look nicer. There are some key things to note about floated objects:
			<ul>
				<li>Floated objects stay within the content area of their containing element. </li>
				<li>If you're floating a text element or a block element, provide a width. Otherwise, if the text is too long, the default behaviour is to expand until it fills up the width of the container.</li>
				<li> Margins on floated elements do not collapse</li>
				<li> You can float any element, both in-line and block.</li>
				<li>Floating in-line elements behave like block elements</li>
				<li>Floating elements cannot float higher than elements that precede it in the document.</li>
				<li>Floated elements don't overlap, even if you multiple floated elements in a row all going to the same side. What they do is stack side-by-side from the edge of whichever side they were floated to. If there's no more room to stack, then the next floated element moves down until its clear of the stack, then slides over until it hits the edge and the process continues until there's no more consecutive floats.</li>
				<li>Once you float an element, the box of its containing element collapses fit around the remaining ones. This may cause it to shrink smaller than the floated element or cause the element box to disappear entirely if there are no other non-floated elements contained. The trick is to <b>float the container as well and give it width of of 100%</b>.

			</ul>
		<dl>
			<dt><code>float</code><br>Value:left,right,none</dt>
			<dd>Used to float an element to the left or right of its containing element.</dd>
			<dt><code>clear</code><br>Value:left,right,both,none</dt>
			<dd>Used to stop an element from wrapping around a floated one and have it start at the next available space below it. The values 'left' and 'right' stop the element from wrapping around elements floated on the left or right respectively. The 'both' value prevents the element from wrapping around any floated element.</dd>
		</dl>
		<h3> Text Wrapping </h3>
		<p> When text wraps around floated objects, they always wrap in a straight line, forming a rectangle around the floated element. This is fine if the floated element is also text but its not as nice for images. To make it comform to the outline of the image we use the <code>shape-outside</code> property.
		<dl>
			<dt><code>shape-outside</code><br>Values:none,circle(..),ellipse(..),polygon(..),url(..)</dt> 
			<dd> Use to help text wrap around images better. The circle value takes in a radius. The ellipse value uses the notation "rx ry <b>at</b> x% y%". The rx is the horizontal radius, ry is the vertical radius, x% is the horizontal position of the ellipse center and y% is the vertical position of the ellipse center. The polygon value takes in a bunch of x,y coordinates separated by commas. The top left corner of the image is 0px 0px and the bottom right corner's coordinates would be equivalent to whatever dimensions your image is in. Finally, the url value can take in the url of an image that has transparent areas. The text will automatically flow into the transparent areas and stop when it hits coloured ones. Note: the <code>shape-outside</code> property allows text to flow into a floated element but it cannot push the text away further than it normally does; use <code>shape-margin</code> for that.</dd>
			<dt><code>shape-margin</code><br>Values:px,rem,em,%</dt>
			<dd>Creates a margin between the text and the outline specified by <code>shape-outside</code>.
	</section>
	<section id="positioning">
		<h2>Positioning Elements</h2>
		<p>Aside from floating, we can move elements around the page using the <code>position</code> property. Like floating, elements positioned this way behave like block elements. Unlike floating, positioned elements can overlap other elements, including other positioned elements.</p>
		<dl>
			<dt><code>position</code><br>Value:static,relative,absolute,fixed</dt>
			<dd>Used to specify how an object is to be positioned. Static is the default and is how elements normally arrange themselves. Relative moves the element box relative to its original position, while keeping its original position as empty space. Absolute moves element box relative to its <dfn>containing block</dfn>(more on this later) and closes up its original position. Fixed moves the element relative to the viewport and makes it stay there, even through scrolling. Fixed objects also have their original position closed up.</dd>
			<dt><code>top|right|bottom|left</code><br>Values:px,rem,em,%,auto</dt>
			<dd>Offset properties used to provide the location for repositioning, based on the positioning format and point of reference specified by the <code>position</code> property. The values for each of the four properties do not correspond to the actual coordinates but rather how far to move away from the corresponding edge; positive values move the element away from that edge, negative values move it closer. It is important to note that by setting offsets on each of the sides, you may end up accidentally changing the dimensions of your positioned element if its containing block is too small. In order words, the size of the positioned element <em>and</em> its offsets has to be less than or equal to the size of its containing block.</dd>
		</dl>
		<h3>Containing Blocks</h3>
		<p>Absolute positioning is based on the element's containing block. This is not always its parent! Here's how we determine the containing block:</p>
			<ul>
				<li>If the positioned element has an ancestor that also has some sort of position property value set for it, then the ancestor is the containing block.</li>
				<li>If there is no ancestor with a position property value, then the containing block is the <em>intial</em> containing block. In pretty much all classes, this is the <code>&lt;html&gt;</code> element.</li>
			</ul>
			<p>An easy way to turn an element's ancestor into its containing block without having to make the ancestor around is to just assign it the style <code>position: relative</code></p>
		<h3>Stacking Positioned elements</h3>
		<dl>
			<dt><code>z-index</code><br>Values:#|auto</dt>
			<dd>Used for positioned elements to change the stacking order. The smaller the z-index, the lower in the stack the element will display. Z-index values do not have to be in order and can be any arbitrary number.</dd>

	</section>
	<section id="Flexbox">
		<h2>Flexboxes</h2>
		<p> Another CSS tool for configuring layouts. To create a flexbox, simply set the container element's <code>display</code> property to 'flex'. When you designate a container element to be a flexbox, you gain the ability to manipulate all of its direct child elements, which have now become <dfn>flex items</dfn>. The flex items are then laid out along a <dfn>flex line</dfn> which is basically a vertical or horizontal axis on the page. By default, the direction the flex items are laid out will correspond to the document's language: left-to-right for English. You can create nested flexboxes by turning the flex items into flexboxes.</p>
		<dl>
			<h3>Flexbox Properties</h3>
			<dt><code>flex-direction</code><br>Values:row,column,row-reverse,column-reverse</dt>
			<dd>Changes the way flex-items get aligned in the flexbox. Default is 'row'. Whatever is set here is the <dfn>main-axis</dfn> and the <dfn>cross-axis</dfn> becomes whatever is perpendicular to the main-axis.</dd>
			<dt><code>flex-wrap</code><br>Values:nowrap,wrap,wrap-reverse</dt>
			<dd> Changes how flex items wrap in the flex box. Default is nowrap, which means flex items squish as much as they can and try to fit. 'Wrap' allows the flex-items to flow onto multiple lines in the same flex-direction, from start of the container to end. 'Wrap-reverse' also allows wrapping across multiple lines but in the oppositeflex-direction (right to left), from the end of the container to the beginning. If the flex-direction is set to 'column' or'column-reverse', the container will expand to accomadate the content unless a height is specified. for the container</dd>
			<dt><code>justify-content</code><br>Values: flex-start,flex-end,center,space-between,space-around</dt>
			<dd> Defines how any extra space should be handled along the main axis. The default is 'Flex-start' which means all the flex-items line up without space at the start of box. 'Flex-end' lines them all without space at the end of box. 'Center' centers the flex-items without space in the middle of the box. 'Space-between' puts the first flex item at the beginning, the last flex item at the end and organizes the remaining flex items so that there is an equal distance between every flex item. 'Space-around' is similar to 'space-between' except the there is space around the first and last elements as well.</dd>
			<dt><code>align-items</code><br>Values:flex-start,flex-end,center,baseline,stretch</dt>
			<dd> Defines how items are arranged along the cross axis. Note: A container height must be set first: otherwise the container just automatically resizes to fit the content meaning there's no point in this property. The default is stretch meaning if there's any space along the cross axis of the container , the items will be stretched to fill that space. 'Flex-start' aligns the items at the start of the cross-axis. 'Flex-end' aligns the items at the end of the cross-axis. 'Center' aligns the items in the middle of the cross axis. Baseline aligns each flex-item individually such that the baselines of the text in each item all line up; this becomes apparent when the font size of the items differ.</dd>
			<dt><code>align-content</code><br>Values:flex-start,flex,end,center,space-around,space-between,stretch</dt>
			<dd> Defines how you'd like multiple lines of flex items to appear in the flexbox. Note: multiple lines of flex items is only possible if some type of wrapping is specified with the <code>flex-wrap</code> property. 
		</dl>
		<dl>
			<h3>Flex Item Properties</h3>
			<dt><code>align-self</code><br>Valuesflex-start,flex-end,center,baseline,stretch:</dt>
			<dd> Same as <code>align-items</code> but for  individual flex items. Will override whatever is set in <code>align-items</code>. If you want to align individual flex items along the main-axis, try using margins to add space between it and the other flex items.</dd>
			<dt><code>flex</code><br>Values:none,0,#,auto</dt>
			<dd> Defines how the flex item "flexes". There are up to three values that can be entered, without comma separation. The first two values can be 0 or 1 and act as toggles to control whether the item can grow or shrink. 0 means no, 1 mean yes. If you want some items to grow larger than the others, give that item a grow value larger than 1 and it will grow that much more, proportionally. For example, an item with a grow value of 2 gets twice as much space as items with 1. The same principle works for the shrink value; a larger shrink value means the item shrinks that much more, prorportionally. The third value is the size of the flex item using measurement units. By default, the values are 0,1,auto meaning flex items can't grow but they can shrink and their base size is kept to whatever's specified in <code>width</code> and <code>height</code>. </dd>
			<dt><code>order</code><br>Values:#</dt>
			<dd> Defines the order the flex item appears in the flex-line. The default value is 0. The lower the order value, the closer they are to the beginning of the flex line. Items with the same flex value will appear in the order that they are in the HTML.</dd>
		</dl>


			
	</section>
<footer>
	
	<a href="index.html">Home</a>
	</div>
</footer>
<html>
