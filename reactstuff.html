<!doctype html>
<html>

<head>
	<title>React.js Fundamentals</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<header>
		<div id="nav">
			<h3>Sections</h3>
			<ul>
				<li><a href="#intro">What is React.js?</a></li>
				<li><a href="#creating_elements">Creating Elements</a></li>
				<li><a href="#components">Components</a></li>
					<ul>
						<li><a href="#nested_components">Components</a></li>
						<li><a href="#props">Component Properties</a></li>
						<li><a href="#nested_components">Nested Components</a></li>
						<li><a href="#list_props">Lists as Properties</a></li>
					</ul>
				<li><a href="#images">Adding Images</a></li>
				<li><a href="#fragments">Fragments</a></li>
				<li><a href="#states">States</a></li>
				<li><a href="#effects">Effects</a></li>
				<li><a href="#reducers">Reducers</a></li>
				<li><a href="#tests">Testing with React</a></li>
			</ul>
		</div>
	</header>
	<main>
		<section id="intro">
			<h1>What is React?</h1>
			<p> As the file extension implies, React.js is Javascript. More specifically, React is a Javascript library that is tailored to creating user interfaces. The documentation for React can be found <a href="https://reactjs.org/docs/getting-started.html" target="_blank">here</a>.
			<h2>Installing React Developer Tools</h2>
			<p>
				To easily view and debug our React code, we'll use the React Developer Tools extension. This will add a component in the browser's developer tools. The following instructions are for Chrome but can easily be used for other browsers.
			</p>
			<ol>
				<li>Download the React Developer Tools extension from the Chrome web store <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank">here.</a></li>
				<li>To check that its working, go to a webpage that has React built in, open the browser's developer tools and in the console type: <code>window.react={};</code>. If its installed, you'll see a "Components" tab with the React logo appear in the tool ribbon.</li>
			</ol>
			<h2>Creating a Project</h2>
			<p> To create a React app, we'll use the Create React App, which will help us generate a base project structure. To use Create React App, we'll first need Node and NPM: <a href="https://www.nodejs.org" target="_blank">www.nodejs.org</a>. Once you've installed Node, check to make sure its at least version 8 or higher by going into Git Bash and typing in <code>node --v</code>. We can now create a project.</p>
			<ol>
				<li>Navigate to wherever you want the project folder to be set up</li>
				<li>Type in <code>npx create-react-app <i class=custom>&lt;folder-name&gt;</i></code> and the app will start building our React project. Note: it will also create a local Git repository too!</li>
				<li>Enter <code>cd <i class=custom>&lt;folder-name&gt;</i></code> to navigate to our newly created project.</li>
				<li>Enter <code>npm start</code> to load the project using a local server into a browser window.</li>
			</ol>
			<p> In our project folder, we'll see that the app generated alot of files and folders for us.</p>
				<ul>
					<li>The <i>src</i> folder contains all the css and js files and will be where most of our work will be done.</li>
					<li>The <i>public</i> folder is where the html as well as images are stored.</li>
					<li> The <i>package.json</i> file contains all the dependencies of our project (all the version numbers of the React components)</li>
				</ul>
		</section>

		<section id="creating_elements">
			<h1>Creating Elements</h1>
			<p>In the <i class="filename">src</i> folder, you'll notice a file called <i class="filename">index.js</i> If you open it up, you'll see a bunch of imports as well as a <code>ReactDOM.render()</code> function.</p>
			<figure><img src="images/react_index_base.png" alt="react index.js file"></figure>
			<p>This function is what we'll be using to create elements and putting them onto the webpage. The first argument for this function is the element that we want to create. The second argument specifies where we'll inject the element we've created. In the base project, this is already set up as <code>document.getElementById('root')</code>. We'll start by creating an element using the <code>React.createElement()</code> function.</p>
			<div class=definition>
				<dt><code>React.createElement("<i class=custom>element</i>", {<i class=custom>property1</i>:<i class=custom>value1</i>,...}, <i class=custom>Child Node1,...</i>)</code></dt>
				<dd>Creates a DOM object using React. The first paramater specifies the element type. The second parameter specifies the element's properties, in a comma-separated list. The third parameter specifies any child nodes for the element ex. text or other elements.</dd>
			</div>
			<p>As an example, we'll create an H1 element, keeping only its default properties and have it say "Hello World"</p>
			<figure><img src="images/react_create_element.png" alt="code for creating h1 element in React"></figure>
			<p>And when we reload our project in the browser...</p>
			<figure><img src="images/react_create_element_result.png" alt="webpage with h1 element"></figure>
			<h2>Creating Elements with JSX</h2>
			<p>Creating elements with the <code>createElement()</code> function is fine for one or two elements but what if we want to add a big block of nested elements like a list? It would be alot of work, not to mention prone to errors, if we just kept nesting a bunch of <code>createElement()</code> functions. Thankfully, <dfn>JSX</dfn> or Javascript as XML, allows us to write HTML tags directly into React!</p>
			<figure><img src="images/react_jsx_list.png" alt="creating list with JSX"></figure>
			<figure><img src="images/react_jsx_list_result.png" alt="webpage with list element"></figure>

		</section>

		<section id="components">
			<h1>React Components</h1>
			<p>Components are basically functions; each component is its own separate block of code that returns HTML.</p>
			<p>In the <i class=filename>src</i> folder, there's already a component file called <i class=filename>app.js</i>. Let's take a look.</p>
			<figure><img src="images/react_component.png" alt="React component code"></figure>
			<p>This file contains a function called <code>App()</code> that is designed to return a bunch of JSX. If you notice on the bottom, there's an export statement; this means that to use this module, we'll need to import it. If we go back to our <i class=filename>index.js</i> file, you'll notice that there's an import statement already:</p>
			<figure><img src="images/react_component_import.png" alt="React component import code"></figure>
			<p>Now if we got to our <code>render()</code> function, we can use our component by declaring it like an HTML element</p>
			<figure><img src="images/react_render_component.png" alt="Insert component into render function"></figure>
			<p>Now when we refresh, we see that our component will be rendered on the page</p>
			<figure><img src="images/react_component_render.png" alt="Rendered react component" id=toobig></figure>
			<p> Some key things to know about creating components:</p>
			<ul>
				<li> <strong>Component names must begin with a capital.</strong> Otherwise it won't render properly. </li>
				<li> The content of each of your components should be enclosed in some sort of container element like &lt;header&gt;, &lt;div<&gt;. This is ensure that they're kept separate from the contents of other components</li>
			</ul>
			<h2 id="nested_components">Nested Components</h2>
			<figure><img src="images/react_nested_components.png" alt="nested components"></figure>
			<p>In the above example, we defined three different components: <code>Header</code>, <code>Body</code>, and <code>Footer</code>. We then shoved them all into our <code>App</code> component, which is currently being rendered. When we refresh our page, we see all three components rendered at once.</p>
			<figure><img src="images/react_nested_components_render.png" alt="rendered nested components"></figure>
			<h2 id="props">Component Properties</h2>
			<p> Components can be loaded with <dfn>properties</dfn> which can allow you to customize their returns. Suppose we have a component that returns "My name is Jacky".</p>
			<figure><img src="images/react_component_name.png" alt="component that prints my name is jacky"></figure>
			<p>What if we wanted it to print out a different name? We could go into the component and change it in there but for a larger component where we have to change multiple values in different places, that might not work as well. Instead, lets give our <code>Name()</code> component a 'name' property.</p>
			<p> To define properties, you go to whereever the component is being referenced (in this case, the <code> App()</code> component) and write it just like any HTML property. In this case, lets create a 'name' property and set it to "Michelle".</p>
			<figure><img src="images/react_component_property.png" alt="defining a component property"></figure>
			<p>Now that our component has a property, how to we use it? Well, every component has access to a resource called <code>props</code>(short for properties), which is where our properties our stored. So we'll need to pass the <code>props</code> to our component, and then call our property using the format <code>{props.<i class=custom>propertyName</i>}</code>.</p>
			<figure><img src="images/react_component_props.png" alt="using props in a component"></figure>
			<p>Now our webpage has a customizable output that is configurable in a centralized location</p>
			<figure><img src="images/react_component_props_result.png" alt="webpage showing property change" height="200px"></figure>
			<p>Keep in mind: props aren't just for storing static strings and numbers. You can declare properties with the outputs of other functions as well. Just remember that if the value is a variable or a function, you need to enclose it with {}.</p>
			<figure><img src="images/react_component_props_function.png" alt="declaring property with function output">
			</figure>

			<h2 id="list_props">Lists as Properties</h2>
			<p>If you're working with alot of data, props can hold lists as well. Suppose Michelle wanted to display a list of her courses. First, we'll make the list.</p>
			<figure><img src="images/react_component_props_list1.png" alt="coding list in JS"></figure>
			<p>Now that the list is created, we'll add it to our props.</p>
			<figure><img src="images/react_component_props_list2.png" alt="list prop"></figure>
			<p>Our component will then take the list and iterate through it, generating an <code>li</code> for each course</p>
			<figure><img src="images/react_component_props_list3.png" alt="using list prop in component"></figure>
			<p>Now Michelle's course list is displayed on the webpage. If we wanted to add or change anything in the list, all we'd need to do is edit the original list we made in JS and the page will be updated automatically without us messing with the HTML. (You can change how the list looks in CSS).</p>
			<figure><img src="images/react_component_props_list4.png" alt="rendered list"></figure>
			<p>There's one last thing to do: assign IDs to each of the list items. If you look at the console now, you'll notice that its throwing a warning. This is because without IDs, things could go wrong if the list was changed after rendering. An easy way to do so is to map each of the list elements as an object with an ID.</p>
			<figure><img src="images/react_component_props_list5.png" alt="Mapping list elements to obejcts with id"></figure>
			<p>Now we just update our props to hold the newly mapped list of objects and then point the <code>key</code> for each <code>li</code> to each object's ID.</p>
			<figure><img src="images/react_component_props_list6.png" alt="using list prop with ID in component"></figure>

			<h2 id="conditional_rendering">Conditional Rendering</h2>
			<p>Another way we can use properties is to control what is being rendered onto the page. This is known as <dfn> conditional rendering</dfn>. To do so, we assign our condition as a property to our <code>App</code> call in our <code>Render()</code> function. For example, we'll create a property called "visible" and give it the value of true.</p>
			<figure><img src="images/react_conditional_props1.png" alt="assigning a conditional property"></figure>
			<p>Now we can use this property by passing <code>props</code> to our <code>App</code> component.</p>
			<figure><img src="images/react_conditional_props2.png" alt="using conditional property for rendering"></figure>
			<p> Here we use a ternary operator that uses our conditional property to decide whether or not Michelle's course list should be rendered onto the page.</p>
		</section>

		<section id="images">
			<h1>Adding Images</h1>
			<p> Adding images in React is pretty straightforward.</p> 
			<ol>
				<li>First, import the image from whever it is stored. 
				<br><code>import <i class=custom>imageVarName</i> from "<i class=custom>./URL</i>"</code>
				<br>React grabs that image then stores it under the specified variable name so we can call it wherever we want.</li>
				<li>Place the image in your desired component(s) using  <code>&lt;img&gt;</code> tags, just like HTML. Instead of a URL for the <code>src</code> all we need to do is put in the variable name we set up earlier.<br><code>&lt;img src={<i class=custom>imageVarName</i>} alt="<i class=custom>...</i>"&gt;</code></li>
		</section>

		<section id="fragments">
			<h1>Fragments</h1>
			<p>When we use the <code>render()</code> function to display our components, it only lets us render one component at a time. If we want to render sibling components or elements, React forces us to enclose them in a container element; that's why we have all these <code>divs</code> holding our code. To keep things neater, React provides a way to contain our related components without having to use so much <code>divs</code>: Fragments.
			<div class=definition>
				<dt><code>&lt;&gt;...&lt;/&gt;</code></dt>
				<dd>React Fragments. Can be used in place of <code>div</code> in order to contain sibling components/elements for simultaneous rendering.</dd>
			</div>
		</section>
		<section id="states">
			<h1>States</h1>
			<p> States are a form of conditional rendering allow us to control what is output onto the screen. One of the advantages of states is that we don't need to set up properties for each configuration. As an added bonus, we don't have to do anything in the index file which helps keeps our rendering and our scripting separate.</p>
			<p> Here's how to set-up states in your React app:</p>
			<ol>
				<li> Import the <code>useState</code> function from the React library.
					<figure><img src="images/react_state_import.png" alt="importing useState function"></figure></li>
				<li> The  <code>useState</code> function creates an array that consists of two elements. The first element is a variable that holds the current state of the React app. The second hold a function that we'll use to change the state i.e. change the value of the state variable. We initiate the state by calling the the useState function, thus creating a state variable and the state-changing function. At the same time, we destructure the array, which allows us to assign variable names to each of those elements. By passing in an argument into the <code>useState</code> function, we also set the initial state value. 
					<figure><img src="images/react_state_initiate.png" alt="initiating states"></figure></li>
				<li> We can now use the function we named to change the state of the app. Note that you can't call the function on its own, it'll generate an indefinite loop. You can however package the function with another aspect like a button.
					<figure><img src="images/react_state_changestate.png" alt="changing states"></figure></li>
			</ol>

		<section id="effects">
			<h1>Effects</h1>
			<p> Effects are another hook in React, along with states. Effects are used for secondary outputs that aren't part of your components: console logs, data loading, etc.</p>
			<p>Here's how to use effects</p>
			<ol>
				<li>Import the <code>useEffect</code> function.
					<figure><img src="images/react_effect_import.png" alt="importing useEffects"></figure></li>
				<li> We can now use the <code>useEffect</code> function to output to console.
					<figure><img src="images/react_effect_console.png" alt="console log with effects"></figure></li>
				<li> The <code>useEffect</code> function can take a second argument called a <dfn>dependency array</dfn>. This array keeps track of any variables you put in as elements and outputs a console log if those variables ever change. If this second argument is left blank, then a console log gets output on every state change. If an empty array is used, then the console log only gets output once. If a dependency is added to the array, then an console log is output every time that specific variable changes.</li>
			</ol>
			<h2>Fetching Data with useEffects and useStates</h2>
			<p>We can use the <code>fetch()</code> function in combination with our <code>useEffect()</code> to retrieve some data from an API. As an example, lets retrieve my account data from the Github API. </p>
			<figure><img src="images/react_effect_fetch.png" alt="code for fetching data with useEffects"></figure>
			<p>First, we use <code>useState()</code> to generate a state variable called <code class=custom>data</code> and a function for setting the value called <code class=custom>setData</code>. We set the initial value of <code class=custom>data</code> to be null for reasons explained later. Next, we'll use the <code>useEffect()</code> to call an anonymous function. The anonymous function will fetch from the Github api URL, then convert that data into a <i class=filename>json</i> format. Finally, the function then calls <code class=custom>setData</code> which associates the data to the <code class=custom>data</code> variable.</p>
			<p>Now, if <code class=custom>data</code> is still null, that means our fetch didn't work so we'll render the message "No data found". Otherwise, we 'stringify' the .json data and output that instead.</p>

			<h2>Handling Loading and Errors with useEffects and useStates</h2>
			<p>When we're fetching data, it's also important to keep track of all the different states like when the data is being loaded, when it's finished loading, and if any errors occur.</p>
			<figure><img src="images/react_effect_loading.png" alt="code for handling load states"></figure>
			<p>We use <code>useState()</code> to add states for loading and errors, initiating the load state as false (because we're not loading anything right now) and the errors to null (cause there's no errors yet). When we start the fetch, we first check to see if there's any value for the <code class=custom>login</code> property; if there isn't then we immediately exit out of the <code>useEffect()</code> block. If there is, then we set <code class=custom>loading</code> to true and start the fetch. Once the data has been retrieved and stored into <code class=custom>data</code>, we set <code class=custom>lading</code> to false. We also add a <code>.catch</code> at the end to handle any errors that may have occured during the fetch.</p>
		</section>

		<section id="reducers">
			<h1>Reducers</h1>
			<p>Reducers are similar to states in that it allows to define an initial state as well as generate a function for changing that state. The difference is that reducers allow you to define the function as well.</p>
			<ol>
				<li>Import the <code>useReducer</code> function from the React library
					<figure><img src="images/react_reducer_import.png" alt="importing reducer"></figure></li>
				<li> The <code>useReducer</code> function takes two arguments. The first is the function, the second is the initial state. Be aware when destructuring the <code>useReducer</code> array: the arguments are function then initial state but the array values are placed initial state, then function.
					<figure><img src="images/react_reducer_initialize.png" alt="initializing the reducer"></figure></li>
			</ol>
			<p>The compactness of reducers makes them useful for managing things like checkboxes and other input forms</p>
		</section>

		<section id="router">
			<H1>React Routers</H1>
			<p>As mentioned earlier, a React app is composed of a single web page whose content is loaded dynamically. If our app needs to have multiple pages, we just load in some new content on the same page to replace the old one. But how does React know which content to load? That's where routing comes in. First we'll need to install the React router so type theses in your command line:<br> <code>npm install react-router@next react-router-dom@next</code> <br><code>npm install history</code>.
			</p>
			<p>Then in our <i class="filename">index.js</i>, we import the BrowserRouter.</p>
			<figure><img src="images/react_router_import.png" alt="importing react router"></figure>
			<p>Next, we give our App access to the router properties by surrounding it with special <code>Router</code> tags in our render call.</p> 
			<figure><img src="images/react_router2.png" alt="router tags"></figure>
			<p>Now, let's create our additional pages. I've created a new file called <i class="filename">pages.js</i> and defined three components: <code>Home</code>, <code>About</code>, and <code>Contacts</code>. Don't forget to import React!</p>
			<figure><img src="images/react_router3.png" alt="router pages"></figure>
			<p>Now in our <i class=filename>App.js</i> file, we can start setting up the routes. First we import <code> Routes</code> and <code>Route</code>, as well as the components that we just created.</p>
			<figure><img src="images/react_router4.png" alt="importing components and route"></figure>
			<p>Then, we create the routes. We use the <code>&lt;Routes&gt;</code> element with a bunch of nested <code>&lt;Route&gt;</code> elements, one for each page. TIP: f you want to make a route for displaying an error if the user tries to go to a path that doesn't exist, just create a route and set the path to * along with your custom error element. </p>
			<figure><img src="images/react_router5.png" alt="react routing skeleton"></figure>
			<p>We then give each route a path and the element (component) it will display</p>
			<figure><img src="images/react_router6.png" alt="react routing paths"></figure>
			<p>Now when we load our webpage, we'll see different things by just changing the path.</p>
			<figure><img src="images/react_router7.png" alt="web route 1">
					<img src="images/react_router8.png" alt="web route 2"></figure>
			<p>Time to add links for our users to easily change views. Back in our <i class=filename>pages.js</i> file, we'll import the <code>Link</code> component and then use that component to generate our links. This component works pretty much the same as anchors in HTML. Instead of an <code>href</code> property though, it uses a <code>to</code> property to point to the target page.</p>
			<figure><img src="images/react_router9.png" alt="adding links">
					<img src="images/react_router10.png" alt="adding links"></figure>


 





		</section>
		<section id="tests">
			<h1>Testing with React</h1>
			<p> One feature of the CreateReact App is its ability to easily run tests. These are important to make sure all our code works as expected before deployment. We can test for pretty much anything; function outputs, render outputs, etc. All we need to do is create <i class=filename>.test</i> files and by running <code>npm test</code> in the console, it will automatically run any <code>test()</code> we put in those files.</p>
			<div class=definition>
				<dt><code>test("<i class=custom>testName</i>", ()=>{<i class=custom>..test setup..</i>});</code></dt>
				<dd>Generates a test that will be run when we call <code>npm test</code>. The first argument is the name of test. The second argument holds the actual test. Its common to put in a callback function as the second argument (as shown above) so that we can write the test as a function. The test must include an <code>expect()</code> function so that the test knows how to decide whether or not the test passes or fails.</dd>
				<dt><code>expect(<i class=custom>object to be checked</i>)</code></dt>
				<dd>For things to work, we expect it to perform a certain way. Given an input, we expect a working function to produce a specific output. Given some HTML, we expect a specific thing to be rendered on the screen. The <code>expect()</code> function helps us test objects by returning whether or not the object meets a certain condition. The <code>expect()</code> function has access to a bunch of methods which will help us create our condition to be tested. For example: <code>expect(x).toBe(y);</code> returns a boolean based on whether x has the same value as y. A full list of methods can be found <a href="https://jestjs.io/docs/en/expect" target="_blank">here</a>.
			</div>

			<h2>Testing Functions</h2>
			<p> Suppose we've written a function called <code>timesTwo()</code>, which multiplies its input by two.</code>.</p>
			<figure><img src="images/react_test_function1.png" alt="timesTwo function code"></figure>
			<p> We want to test it to make sure it actually works. First we'll create a file to keep all our tests in: <i class=filename>functions.test.js</i>. Then in this file, we'll import our function in so we can test it. </p>
			<figure><img src="images/react_test_function2.png" alt="importing function to be tested"></figure>
			<p>Remember that things need to be <strong>exported</strong> before they can be imported, so we'll go back and export our function by adding the <code>export</code> keyword.</p>
			<figure><img src="images/react_test_function3.png" alt="exporting function for testing"></figure>
			<p>Now we can write the tests!</p>
			<figure><img src="images/react_test_function4.png" alt="code for test"></figure>
			<p>Remember to use <code>npm test</code> in the command line to run the tests.</p>

			<h2>Testing Renders</h2>
			<p>Suppose we have the following <code>App()</code>. </p>
			<figure><img src="images/react_test_render1.png" alt="app code"></figure>
			<p> We want to make sure our render has an output of "Hello World" as an H1. So lets write a test. We'll create a file called <i class=filename>App.test.js</i> to hold all our render tests. We'll also need to import the <code>render()</code> function from the React testing library as well as the <code>App</code> itself. </p>
			<figure><img src="images/react_test_render2.png" alt="importing render and app"></figure>
			<p>Now for our test.</p>
			<figure><img src="images/react_test_render3.png" alt="code for testing render"></figure>
			<p> We use the <code>render</code> function to render our app object and destructure the object into the query <code>getByText</code>. Then we call the <code>getByText</code> function to retrieve the node containing "Hello World" using a regular expression. We finish off with our <code>expect()</code> line. More about queries <a href="https://testing-library.com/docs/queries/about/" target="_blank">here</a>.



		</section>
	</main>

	<footer>
		<ul>
		<li><a href="index.html">Home</a></li>
		<li><a href="htmlstuff.html">HTML stuff</a></li>
		<li><a href="cssstuff.html">CSS Stuff</a></li>
		<li><a href="jsstuff.html">JS stuff</a></li>
		<li><a href="nodestuff.html">Node.js Stuff</a></li>
		<li><a href="gitstuff.html">Git stuff</a></li>
		</ul>
	</footer>
</body>


</html>